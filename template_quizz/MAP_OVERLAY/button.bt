PROTO BUTTON [
	exposedField SFVec2f 	translation 	0 0
	exposedField SFFloat 	rotationAngle 	0.0
	exposedField SFVec2f 	scale 			1 1
	exposedField SFVec2f 	size 			50 50
	exposedField MFString 	backImage 		[]
	exposedField MFString 	overImage 		[]
	exposedField MFString 	text 			[]
	exposedField SFColor 	textColor 		1 1 1
	exposedField SFFloat 	textSize 		18
	exposedField SFColor 	overColor 		1 0.5 0.8
	exposedField SFColor 	backColor 		0.1 0.1 0.1
	exposedField MFString 	family 			["ARIAL"]
	exposedField SFVec2f	layoutSize		-1 -1
	eventOut 	 SFBool 	onClick
	eventIn 	 SFBool 	doClick
] 
{
	DEF TR Transform2D {
		translation 	IS translation
		rotationAngle	IS rotationAngle
		scale 			IS scale
		children [
			Shape {
				appearance DEF BColor Appearance {
					material Material2D {
						emissiveColor IS backColor
						filled TRUE
					}
				}
			}
			Shape {
				appearance DEF OColor Appearance {
					material Material2D {
						emissiveColor IS overColor
						filled TRUE
					}
				}
			}
			Shape {
				appearance DEF APP_BACK Appearance {
					texture ImageTexture {
						url IS backImage
					}
					material DEF MAT_LINE Material2D {
						lineProps DEF LINE_PROP LineProperties {
							width 0
						}
					}
				}
			}
			Shape {
				appearance DEF APP_OVER Appearance {
					texture ImageTexture {
						url IS overImage
					}
					material USE MAT_LINE
				}
			}
			DEF TS TouchSensor {}
			DEF SR Shape {
				geometry Rectangle {
						size IS size
				}
				appearance USE APP_BACK
			}
			DEF LAYOUT Layout {
				size IS layoutSize
				wrap TRUE
				justify 	["MIDDLE" "FIRST"]
				children [
					DEF ST Shape {
						geometry DEF TX Text {
							string IS text
							fontStyle FontStyle {
								justify		["MIDDLE"]
								size 		IS textSize
								family 		IS family
							}
						}
						appearance Appearance {
							material DEF MT Material2D {
								emissiveColor 	IS textColor
								filled 			true
							}
						}
					}
				]
			}
			DEF SCRIPT Script {
				field SFNode overColor 	USE OColor
				field SFNode backColor 	USE BColor
				field SFNode rect 			USE SR
				field SFNode app_over 		USE APP_OVER
				field SFNode app_back 		USE APP_BACK
				field SFNode layout		USE LAYOUT
				field SFBool Active 		false
				field SFBool CanClick 		true
				eventIn SFBool Click 		IS doClick
				eventIn SFBool OnActive
				eventIn SFBool OnOver
				eventIn MFString 	setImgButtonBack 	IS backImage
				eventIn MFString 	setImgButtonOver 	IS overImage
				eventIn MFString 	setText 			IS text
				eventIn	SFVec2f 	setLayoutSize		IS layoutSize
				eventIn	SFVec2f	setRectangleSize	IS size
				eventOut SFBool DoClick IS onClick
				
				url ["javascript:
					function initialize() {
						text = false;
						layoutSize = new SFVec2f (-1, -1);
						if (app_back.texture.url[0] != '') {
							back = app_back;
						}
						else {
							back = backColor;
							rect.appearance = back;
						}
						
						if (app_over.texture.url[0] != '') {
							over = app_over;
						}
						else {
							over = overColor;
						}
					}
					# if the size of the layout was not implicitly defined yet,
					# use the size of the rectangle (button) to set it. (layout size == rectangle size)
					# This step is mandatory otherwise the map container will be shifted away because
					# both the map instance and the buttons (zoom buttons in this case) contain layouts =>
					# layout in layout as the buttons are inside the map layout => auto positioning of the map layout
					# computed by the player because of the layout hierarchy
					function setRectangleSize(rSize) {
						if (!isDefault(layoutSize)) {
							return;
						}
						if (!isDefault(rSize)) {
							layout.size = new SFVec2f (rSize.x, rSize.y);
						}
					}
					
					function setImgButtonBack(val) {
						if (val[0] != '') {
						   back = app_back;
						   rect.appearance = back;
						} 
					}
					function setImgButtonOver(val) {
						if (val[0] != '') {
						   over = app_over;
						} 
					}

					function setLayoutSize(lSize) {
					#	print ('[ BUTTON ]: Set layout size: ' + lSize);
						layoutSize = new SFVec2f (lSize.x, lSize.y);
						layout.size = layoutSize;
					}
					
					function setText(txt) {
					#	print ('[ BUTTON ]: Set text: ' + txt);
						text = txt;
						if (!isDefault(layoutSize)) {
							layout.size = layoutSize;
						}
					}
					
					function OnActive(value, timestamp) {
						Active = value;
						if ( value )
						{
							rect.appearance = over;
							CanClick = true;
						}
						else
						{
							rect.appearance = back;
							if ( CanClick )
							{
								DoClick = true;
							}
						}
					}
					function OnOver(value) {
						if ( Active && value )
						{
							CanClick = true;							
						}
						else
						{
							CanClick = false;
						}
					}
					function Click(value) {
						if ( !value ) return;
						DoClick = true;
					}
					
					function isDefault(vect2f) {
						return (vect2f.x == -1 && vect2f.y == -1);
					}

				"]
			}
		]
	}
	ROUTE TS.isActive TO SCRIPT.OnActive
	ROUTE TS.isOver TO SCRIPT.OnOver
}